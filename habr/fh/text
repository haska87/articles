<h3>FEniCS - инструмент для решения краевых задач, описываемых дифференциальными уравнениями в частных производных, методом конечных элементов.
</h3>
<img src="https://fenicsproject.org/wp-content/uploads/2016/10/design.jpg" alt="image"/>

Для численного моделирования физических процессов, которые описываются дифференциальными уравнениями в частных производных, существуют множество вычислительных пакетов различного уровня абстракции. Одним из них является вычислительный пакет <a href="http://fenicsproject.org">FEniCS</a>. Основным достоинством FEniCS-а является простая формулировка вариационного уравнения, близкая к математических обозначениям. Вариационную задачу получаем из дифференциального уравнения в частных производных. 

Решение задач с помощью FEniCS состоит из следующих шагов:
<ol>
	<li>Определение дифференциального уравнения в частных производных, задание граничных условий и представление в вариационной формулировке;</li>
	<li>Выбор конечных элементов, определение сеточной задачи, реализация численного решения;</li>
	<li>Проведение экспериментов, вывод промежуточных значений, вычисление производных значений, визуализация результатов.</li>
</ol>
Кроме автоматического решения линейной и нелинейной вариационной задачи, к основным особенностям вычислительного пакета FEniCS выделяются:
<ul>
	<li>Автоматическая контроль ошибок и адаптивность, возможность задания функционала, которая должна минимизироваться с определенной точностью;</li>
	<li>Расширяемая библиотека метода конечных элементов: кроме стандартных конечных элементов, таких как лагранжевы, поддерживаются разрывные методы галеркина, векторные элементы и специальные типы такие как Crouzeix-Raviart;</li>
	<li>Высокопроизводительная линейная алгебра, несколько вариантов реализации линейной алгебры, такие как <a href="http://www.mcs.anl.gov/petsc/">PETSc</a>, <a href="http://trilinos.sandia.gov/packages/epetra/">Trilinos/Epetra</a>, <a href="http://www.boost.org/doc/libs/release/libs/numeric/ublas/doc/index.htm">uBLAS</a>  и <a href="http://www.simunova.com/de/node/24">MTL4</a> , а также библиотека для решения больших разреженных задач на собственные значения <a href="http://slepc.upv.es">SLEPc</a>, в которой параллельные вычисления поддерживаются пакетами PETSc, Trilinos/Epetra и SLEPc;</li>
	<li>Поддержка расчетов на одно-, двух- и трехмерных областях, адаптивные сетки;</li>
	<li>Обработка результатов, возможность визуализации сетки, функций и полученных результатов, поддержка широко используемого формата <a href="http://www.vtk.org/">VTK</a> ;</li>
	<li>Возможность использования языков программирования Python и C++, подобные интерфейсы классов и функций для обоих языков;</li>
	<li>Подробная документация и большое количество примеров, детальное описание алгоритмов и реализации пакета;</li>
	<li>Простая установка на большинство известных платформ.</li>
</ul>

<h3>Установка</h3>
Компоненты FEniCS могут быть установлены на Linux, Windows и Mac OS X платформы. Установочные файлы и исходники проекта могут быть скачаны с официального сайта пакета. На сайте дается детальные описания как установить на ту или иную платформу. Хотя FEniCS доступен для нескольких платформ и операционных систем, рекомендуется устанавливать на <a href="http://www.ubuntu.com/">Ubuntu Linux</a> , поскольку это самый простой и надежный вариант. На платформах Windows или Mac OS X некоторые компоненты FEniCS для проведения научных вычислений могут быть не доступны или установлены с большим количеством требуемых программ. FEniCS на Ununtu можно установить через  следующие команды:
<source lang="bash">
sudo add-apt-repository ppa:fenics-packages/fenics
sudo apt-get update
sudo apt-get install --no-install-recommends fenics
sudo apt-get dist-upgrade
</source>

<h3>Тестовая задача</h3>
Для демонстрации основных возможностей пакета FEniCS будем рассматривать модельную задачу. Сперва определим дифференциальное уравнение в частных производных и зададим граничные условия для получения краевой задачи. Далее сформулируем вариационную задачу для решения методом конечных элементов.

<h4>Дифференциальное уравнение</h4>
Рассмотрим простейший пример, уравнение Пуассона в области $inline$\Omega$inline$:
$$display$$- \Delta u = f,
$$display$$
где $inline$u$inline$ -- искомая функция, $inline$f$inline$ -- заданная функция, $inline$\Delta$inline$ -- оператор Лапласа. Уравнение  дополняем граничным условием Дирихле:
$$display$$u(x) = g(x), \quad {x} \in \partial \Omega.$$display$$
Система уравнений представляет собой краевую задачу, которая должна быть численно решена с помощью пакета FEniCS.

Для простоты выберем двухмерную область с координатами $inline$x_1$inline$ и $inline$x_2$inline$.

Поскольку FEniCS для решения дифференциальной задачи использует метод конечных элементов, дифференциальное уравнение нужно представить в вариационной формулировке. 
<spoiler title="Вариационная формулировка">
Основным способом перевода дифференциальной задачи в вариационную является:
<ol>
	<li>умножение уравнения на некую функцию $inline$v$inline$,</li>
	<li>интегрирование полученного уравнения по области $inline$\Omega$inline$,</li>
	<li>замена производных второго порядка через интегрирование по частям.</li>
</ol>

Функция $inline$v$inline$ в терминах конечных элементов называется тестовой функцией(test function), а искомая функция $inline$u$inline$ -- пробной функцией(trial function).

В нашем случае мы умножаем уравнение Пуассона на $inline$v$inline$ и интегрируем по области $inline$\Omega$inline$:

$$display$$- \int_\Omega v \Delta u \; d{x} = 
\int_\Omega f v \; d{x}.
$$display$$
Далее заменяем оператор Лапласа с помощью интегрирования по частям и используем формулу Гаусса-Остроградского для перехода в поверхностный интеграл:
$$display$$- \int_\Omega v \Delta u \; d{x} = 
\int_\Omega \nabla u \nabla v \; d{x} -
\int_{\partial \Omega} v \frac{\partial u}{\partial {n}} \; ds,
$$display$$

где $inline$\partial u / \partial {n}$inline$ -- производная по внешней нормали границы $inline$\partial \Omega$inline$. Тестовая функция необходима для того, чтобы избавиться от интеграла по поверхности. Поэтому берем такую тестовую функцию, которая на границе $inline$\partial \Omega$inline$ равняется нулю $inline$v = 0$inline$. Тогда получаем следующее уравнение:
$$display$$\int_\Omega \nabla u \nabla v \; d{x} =
\int_\Omega f v \; d{x}.
$$display$$
Это уравнение называется <b>слабой формой</b> первоначальной краевой задачи. Полученная вариационная задача формулируется следующим образом: нужно найти такую функцию $inline$u \in V$inline$, которая удовлетворяет уравнению:
$$display$$\int_\Omega \nabla u \nabla v \; d{x} =
\int_\Omega f v \; d{x}, \quad \forall v \in \hat{V},
$$display$$

где $inline$V$inline$ -- пространство пробных функций, а $inline$\hat{V}$inline$ -- пространство тестовых функций:
$$display$$
V  = \{ u({x}) \in H^1(\Omega): \,  u({x}) = g({x}), \, {x} \in \partial \Omega \},
\hat{V}  = \{ v({x}) \in H^1(\Omega): \,  v({x}) = 0, \, {x} \in \partial \Omega \}.
$$display$$
$inline$H^1(\Omega)$inline$ -- пространство Соболева содержащий функции $inline$v$inline$, такие что $inline$v^2$inline$ и $inline$|\nabla v|^2$inline$ конечно интегрируемы в области $inline$\Omega$inline$. 
</spoiler>

Для решения вариационной задачи используется метод конечных элементов. Преимуществами метода конечных элементов является возможность определения произвольной области и сгущения сетки в наиболее интересных подобластях. После аппроксимации вариационной задачи получаем систему линейных алгебраических уравнений, решение которой реализована в пакетах линейной алгебры.
<spoiler title="Конечно-элементная аппроксимация">
В методе конечных элементов приближенное решение дифференциального уравнения находится как линейная комбинация известных простых функций:

$$display$$u({x}) = \sum_{i=1}^N y_i \phi_i({x}),
$$display$$
где $inline${y}$inline$ -- вектор степеней свободы (неизвестные, которые нужно вычислить). Выбираем дискретное пространство пробных функций $inline$V_h \subset V$inline$, базис которого будет равняться множеству функций $inline$\{\phi_i\}_{i=1}^N$inline$. Так же определяем дискретное пространство для тестовых функций $inline$\hat{V}_h \subset \hat{V}$inline$ с базисом $inline$\{\hat{\phi}_i\}_{i=1}^N$inline$, тогда тестовая функция будет выражаться следующим образом: 
$$display$$v({x}) = \sum_{i=1}^N \hat{y}_i \hat{\phi}_i({x}),
$$display$$

Дискретная вариационная задача формулируется следующим образом: нужно найти $inline$u({x}) \in V_h \subset V$inline$ такой, что:
$$display$$\int_\Omega \nabla u \nabla v \; d{x} =
\int_\Omega f v \; d{x}, \quad \forall v({x}) \in \hat{V}_h \subset \hat{V}.
$$display$$

Поскольку вариационная задача заключается в нахождении пробных функций удовлетворяющей верхнему уравнению  для любой тестовой функции, значит приближение $inline$u(x)$inline$  должна удовлетворять всем базисным функциям пространства тестовых функций:

$$display$$\sum_{j=1}^N y_j \int_\Omega \nabla \phi_i, \nabla \hat{\phi}_i \; d{x} =
\int_\Omega f \hat{\phi}_i \; d{x}, \quad i = 1, 2, \dots, N.
$$display$$
Таким образом исходная задача сводится к решению системы линейных алгебраических уравнений (СЛАУ):

$$display$$A{y} = {b},
$$display$$
где
$$display$$
A_{ij} = \int_\Omega \nabla \phi_j \nabla \hat{\phi_i} \, d{x}, 
\quad
b_i = \int_\Omega f \hat{\phi}_i \, d{x}.
$$display$$

Уравнение в более общем виде записывается так:
$$display$$a(u,v) = L(v).
$$display$$

В нашей задаче:
$$display$$a(u,v) = \int_\Omega \nabla u \nabla v \, dx, 
\quad
L(v) = \int_\Omega f v \, dx,
$$display$$
где $inline$a(u,v)$inline$ -- называется <b>билинейной формой</b>, а $inline$L(v)$inline$ -- <b>линейной формой</b>.
</spoiler> 

В программном пакете FEniCS построение СЛАУ и решение реализовано, поэтому остается записать вариационную задачу и выбрать конечные элементы.

<spoiler title="Конечные элементы">
Для решения СЛАУ, определяется пространства для пробных и тестовых функций  $inline$V, \hat{V}$inline$. 
Для этого сперва поделим область, в котором ищем решение, на конечное множество не пересекающихся ячеек (подобласти) $inline$\Omega_h = \{\omega\}$inline$:
$$display$$\bigcup \limits_{\omega \in \Omega_h} \omega = \Omega.
$$display$$
Множество $inline$\Omega_h$inline$ представляет собой сетку для области $inline$\Omega$inline$. Ячейки обычно для простоты бывают многоугольниками, такими как: отрезок, треугольник, четырехугольники, тетраэдры или гексаэдры. Но ячейки могут быть и другой формы, скажем, частично кривыми для учета границы области. Для большинства задач треугольники или тетраэдры наиболее подходящие формы для ячеек.

Для каждой ячейки $inline$\omega$inline$ определяем локальное пространство $inline$\mathcal{V}$inline$, которое определяет пробную функцию $inline$v$inline$, только в своей ячейке. Тогда пространство $inline$V_h$inline$ в области $inline$\Omega$inline$ определяется множеством локальных пространств $inline$\mathcal{V}$inline$ пробных функций. 
Ячейка $inline$\omega$inline$ вместе с локальным пространством $inline$\mathcal{V}$inline$ и правилами определения функций в $inline$\mathcal{V}$inline$ называется <b>конечным элементом</b>. Тем самым, конечный элемент определяется:
<ul>
	<li>ячейкой $inline$\omega$inline$ -- подобласть $inline$\Omega$inline$,</li>
	<li>пространством функций $inline$\mathcal{V}$inline$ с базисом $inline$\{\phi\}_{i=1}^n$inline$,</li>
	<li>степенью свободы -- количество узлов ячейки, которые определяют численное решение.</li>
</ul>
</spoiler>

Среди существующих стандартных конечных элементов отметим лагранжевые, в также разрывные лагранжевые элементы.

<h3>Программа</h3>
Рассматриваемая задача Пуассона решается в области $inline$\Omega$inline$ с правой частью $inline$f({x})$inline$ и граничным условием $inline$g({x})$inline$. Для проверки корректности реализованного решения будем решать задачу с известным точным решением. Пусть точное решение будет
$$display$$u(x_1, x_2) = 1 + x_1^2 + 2x_2^2$$display$$


Тогда правая часть и граничное условие соответственно будут выражаться следующими образом:
$$display$$f(x_1, x_2)  = -6, \\
g(x_1, x_2)  = 1 + x_1^2 + 2x_2^2.
$$display$$

Область, в котором будем находить численное решение, выберем простую квадратную с единичными сторонами:
$$display$$\Omega = \left(x \; | \; x = (x_1, x_2), \; 0 \leq x_i \leq1, \; i = 1, 2 \right).
$$display$$

Рассмотрим реализацию на <b>python</b>-е описывая код шаг за шагом.

Во-первых импортируем модуль dolfin:
<source lang="python">from dolfin import *</source>

Начнем с определения сетки области и конечного элемента пространства $inline$V$inline$.
Для единичной квадратной области мы можем использовать класс UnitSquareMesh.  Чтобы создать сетку, состоящую из 32 х 32 квадратов, где каждый квадрат состоит из  двух треугольников, мы делаем следующее:

<source lang="python">
#Создаем сетку и определяем пространство функций
mesh = UnitSquareMesh(32, 32)
V = FunctionSpace(mesh, "Lagrange", 1)
</source>

Второй аргумент FunctionSpace является конечным элементом, а третий аргумент задает степень полинома. Таким образом, наше пространство $inline$V$inline$ состоит из лагранжевых  конечных элементов первого порядка (непрерывные кусочно-гладкие полиномиальные функции). 


